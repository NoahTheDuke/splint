(ns hooks.noahtheduke.splint.rules
  (:require
   [clj-kondo.hooks-api :as api]))

(defn walk
  [inner outer form]
  (if (:children form)
    (outer (assoc form :children (mapv inner (:children form))))
    (outer form)))

(defn postwalk
  [f form]
  (walk #(postwalk f %) f form))

(defn reg-node-finding!
  [obj opts]
  (let [{:keys [row col end-row end-col]} (meta obj)]
    (api/reg-finding!
     (conj {:row row
            :col col
            :end-row end-row
            :end-col end-col}
           opts))))

(defn check-pattern
  [finds children]
  (postwalk
   (fn [obj]
     (when (and (api/list-node? obj)
                (first (:children obj))
                (symbol? (api/sexpr (first (:children obj)))))
       (let [[c bind pred & args] (:children obj)]
         (when-let [kind (#{'? '?+ '?* '?? '?|} (api/sexpr c))]
           (when-not bind
             (reg-node-finding! obj {:message "must have binding"
                                     :type :splint/arg-count}))
           (when (seq args)
             (let [{:keys [row col]} (meta (first args))
                   {:keys [end-row end-col]} (meta (last args))]
               (api/reg-finding!
                {:message "too many args"
                 :type :splint/arg-count
                 :row row
                 :col col
                 :end-row end-row
                 :end-col end-col})))
           (when-not (symbol? (api/sexpr bind))
             (reg-node-finding! bind
                                {:message "binding must be a symbol"
                                 :type :lazytest/binding-type}))
           (case kind
             (? ?* ?+ ??)
             (when pred
               (let [pred-sym (api/sexpr pred)]
                 (if (symbol? pred-sym)
                   (let [v (api/resolve {:name pred-sym
                                         :call true})]
                     (if v
                       (swap! finds conj (with-meta (api/token-node
                                                     (symbol (str (:ns v)) (str (:name v))))
                                           (meta pred)))
                       (reg-node-finding! pred
                                          {:message (str "Unresolved symbol: " pred-sym)
                                           :type :unresolved-symbol})))

                   (reg-node-finding! pred
                                      {:message "predicate must be a symbol"
                                       :type :lazytest/predicate}))))
             ?| (cond
                  (api/vector-node? pred)
                  (if (seq (:children pred))
                    (doseq [invalid (remove api/token-node? (:children pred))]
                      (reg-node-finding! invalid
                                         {:message "incorrect type for ?| vector"
                                          :type :lazytest/choice-type}))
                    (reg-node-finding! pred
                                       {:message "?| requires a non-empty vector predicate"
                                        :type :lazytest/choice}))
                  pred
                  (reg-node-finding! pred
                                     {:message "?| requires a vector predicate"
                                      :type :lazytest/choice})
                  :else
                  (reg-node-finding! obj
                                     {:message "?| choice vector must exist"
                                      :type :lazytest/choice}))
             #_:else nil))))
     obj)
   children)
  @finds)

(defn validate-type
  [node pred t]
  (when-not (pred node)
    (reg-node-finding! node
                       {:message (format "Expected: %s, received: %s" t (name (api/tag node)))
                        :type :type-mismatch})))

(defn int-node? [v]
  (and (api/token-node? v)
       (int? (api/sexpr v))))

(defn bool-node? [v]
  (and (api/token-node? v)
       (boolean? (api/sexpr v))))

(defn validate-rule
  [node]
  (if-not (api/map-node? node)
    (reg-node-finding! node {:message (format "Expected: map, received: %s" (name (api/tag node)))
                             :type :type-mismatch})
    (do (doseq [[k v] (partition 2 (:children node))]
          (case (:k k)
            :patterns (validate-type v api/vector-node? "vector")
            :message (validate-type v api/string-node? "string")
            :init-type (validate-type v api/keyword-node? "keyword")
            :min-clojure-version (do
                                   (validate-type v api/map-node? "map")
                                   (doseq [[version-k version-v] (partition 2 (:children v))]
                                     (case (:k version-k)
                                       :major (validate-type version-v int-node? "int")
                                       :minor (validate-type version-v int-node? "int")
                                       :incremental (validate-type version-v int-node? "int")
                                       #_:else nil)))
            :autocorrect (validate-type v bool-node? "boolean")
            :ext (validate-type v #(let [% (api/sexpr %)]
                                     (or (keyword? %)
                                         (and (sequential? %)
                                              (every? keyword? %))))
                                "keyword or seq of keywords")
            #_:else nil))
        (let [m (api/sexpr node)]
          (cond
            (and (:pattern m) (:patterns m))
            (reg-node-finding! node
                               {:message "Must define only one of :pattern OR :patterns"
                                :type :splint/spec})
            (< 1 (count (select-keys m [:replace :on-match])))
            (reg-node-finding! node
                               {:message "Must define only one of :replace OR :on-match"
                                :type :splint/spec}))))))

(defn defrule
  [{:keys [node]}]
  (let [[defrule rule-name docs m] (:children node)
        used-preds (let [entries (->> (:children m)
                                      (partition 2)
                                      (group-by #(:k (first %)))
                                      (#(select-keys % [:pattern :patterns]))
                                      (not-empty))
                         pattern (second (first (:pattern entries)))
                         patterns (mapcat (comp :children second) (:patterns entries))
                         finds (atom [])]
                     (doseq [pattern (cons pattern patterns)]
                       (check-pattern finds pattern))
                     (seq @finds))
        new-node (api/list-node
                  [(with-meta (api/token-node 'def) (meta defrule))
                   (with-meta (api/token-node (symbol (name (api/sexpr rule-name))))
                     (meta rule-name))
                   docs
                   (if used-preds
                     (update m :children concat [(api/token-node :used-predicates)
                                                 (api/vector-node used-preds)])
                     m)])]
    (validate-rule m)
    {:node (with-meta new-node (meta node))}))
